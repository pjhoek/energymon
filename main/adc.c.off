#include <stdio.h>
#include <inttypes.h>
#include <math.h>
#include "sdkconfig.h"
#include "esp_timer.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"

#define CONVST_PIN GPIO_NUM_4 // GPIO4 - Start conversion
#define BUSY_PIN GPIO_NUM_27  // GPIO27 - Conversion status
#define CS_PIN GPIO_NUM_15    // GPIO15 - Chip select
#define RESET_PIN GPIO_NUM_25 // GPIO25 - Hardware reset

#define SCK_PIN GPIO_NUM_5   // GPIO5 - SCK
#define MISO_PIN GPIO_NUM_21 // GPIO21 - MISO
#define MOSI_PIN GPIO_NUM_19 // GPIO19 - MOSI (unused)

#define NUM_SAMPLES 2000
static const double LSB_10V = 20.0 / 262144.0;
//static const double I_FS_15AMP = LSB_10V * 15;
static const double V_FS_240Volt = LSB_10V * 509.9576;
static const int32_t OFFSET[8] = {9,1,-2,6,-2,3,-6,-2};

// Channel we determine the sample period from (use voltage channel)
#define VOLTAGE_CH 0

static uint8_t rawBytes[18];            // Store raw bytes
static int32_t adcData[NUM_SAMPLES][8]; // ADC values
static double calcRms[8];
static double calcPwr[8];


static void setup_pin_input(int pin)
{
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << pin),
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE};
    ESP_ERROR_CHECK(gpio_config(&io_conf));
}

static void setup_pin_output(int pin)
{
    gpio_config_t io_conf = {
        .pin_bit_mask = (1ULL << pin),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE};
    ESP_ERROR_CHECK(gpio_config(&io_conf));
}

static void loop(spi_device_handle_t spi);

void app_main()
{
    printf("Hello world!\n");

    setup_pin_output(CONVST_PIN);
    setup_pin_input(BUSY_PIN);
    setup_pin_output(CS_PIN);
    setup_pin_input(RESET_PIN);

    gpio_set_level(CONVST_PIN, 1);
    gpio_set_level(CS_PIN, 1);
    gpio_set_level(RESET_PIN, 0);

    // Hardware reset pulse
    gpio_set_level(RESET_PIN, 1);
    esp_rom_delay_us(1);
    gpio_set_level(RESET_PIN, 0);
    vTaskDelay(pdMS_TO_TICKS(1));

    // --- 1. Configure SPI bus ---
    spi_bus_config_t buscfg = {
        .mosi_io_num = MOSI_PIN,
        .miso_io_num = MISO_PIN,
        .sclk_io_num = SCK_PIN,
        .quadwp_io_num = -1, // Not used
        .quadhd_io_num = -1, // Not used
        .max_transfer_sz = 0 // Default
    };

    ESP_ERROR_CHECK(spi_bus_initialize(HSPI_HOST, &buscfg, SPI_DMA_CH_AUTO));

    // --- 2. Add SPI device (sets clock, mode, bit order) ---
    spi_device_interface_config_t devcfg = {
        .clock_speed_hz = 30 * 1000 * 1000, // 25 MHz
        .mode = 1,                          // SPI_MODE2
        .spics_io_num = -1,                 // CS_PIN,         // Hardware CS
        .queue_size = 1};

    spi_device_handle_t spi;
    ESP_ERROR_CHECK(spi_bus_add_device(HSPI_HOST, &devcfg, &spi));

    while (true)
    {
        loop(spi);

        // FIXME
        vTaskDelay(1);
        // TODO RESET IDLE TASK INSTEAD
        // taskYIELD();
    }
}

static void calcRmsAndPower(int ch, int startSample, int endSample)
{
    uint64_t sumRms = 0;
    int64_t sumPwr = 0;
    for (int i = startSample; i < endSample; i++)
    {
        int32_t val = adcData[i][ch];
        sumRms += val * val;
        sumPwr += val * adcData[i][VOLTAGE_CH];
    }

    uint32_t numSamples = endSample - startSample;
    calcRms[ch] = sqrt(((double)sumRms) / ((double)numSamples));
    calcPwr[ch] = ((double)sumPwr) / ((double)numSamples);
}

static bool waitForBusy(int state, uint32_t timeoutMicros)
{
    int64_t then = esp_timer_get_time();
    while (gpio_get_level(BUSY_PIN) != state)
    {
        if (esp_timer_get_time() - then > timeoutMicros)
        {
            // Timeout
            return false;
        }
    }

    // BUSY is now in state `state`
    return true;
}

static void doRead(spi_device_handle_t spi)
{
    if (!waitForBusy(0, 10 * 1000))
    {
        printf("low wait timeout\n");
    }

    gpio_set_level(CONVST_PIN, 0);
    uint32_t then = esp_cpu_get_cycle_count();
    while (esp_cpu_get_cycle_count() - then < 10)
        ;
    gpio_set_level(CONVST_PIN, 1);

    if (!waitForBusy(1, 10))
    {
        printf("high wait timeout\n");
    }

    gpio_set_level(CS_PIN, 0);
    spi_transaction_t t = {
        .length = 18 * 8,  // bits
        .tx_buffer = NULL, // send nothing
        .rx_buffer = rawBytes,
        .flags = 0};
    ESP_ERROR_CHECK(spi_device_polling_transmit(spi, &t));
    gpio_set_level(CS_PIN, 1);
}

static void readAllChannels(spi_device_handle_t spi, int32_t *data)
{
    doRead(spi);

    for (int ch = 0; ch < 8; ch++)
    {
        int startBit = ch * 18;
        int startByte = startBit / 8;

        uint32_t buf = 0;
        for (int i = 0; i < 3; i++)
        {
            buf = (buf << 8) | rawBytes[startByte + i];
        }

        int shift = ((startByte + 3) * 8) - (startBit + 18);
        uint32_t val = (uint32_t)((buf >> shift) & 0x3FFFF);

        if (val & 0x20000)
        {
            val |= 0xFFFC0000;
        }

        data[ch] = val - OFFSET[ch];
       // printf("val: %.6ld\n",data[0]);
    }
}

static void printStored()
{
    

    printf("RMS0: %.6lf RMS Volts: %.6lf\n", calcRms[0] * LSB_10V, calcRms[0] * V_FS_240Volt );
    printf("RMS1: %.6lf\n", calcRms[1] * LSB_10V);
    printf("RMS2: %.6lf\n", calcRms[2] * LSB_10V);
    printf("RMS3: %.6lf\n", calcRms[3] * LSB_10V);
    printf("RMS4: %.6lf\n", calcRms[4] * LSB_10V);
    printf("RMS5: %.6lf\n", calcRms[5] * LSB_10V);
    printf("RMS6: %.6lf\n", calcRms[6] * LSB_10V);
    printf("RMS7: %.6lf\n", calcRms[7] * LSB_10V);
    printf("PWR1: %.6lf\n", calcPwr[1] * V_FS_240Volt * LSB_10V);

    // for (int chan =0; chan <=7; chan++){
    //     for (int c = 0; c < NUM_SAMPLES; c++) {
    //     printf("ch: %d val: %ld\n", chan, adcData[c][chan]);
    //     }
    // }

    printf("---------------------------------------------------------------------------------------------------------------------------------\n");
}

// set true for DC testing, false for AC
#define DC_MODE 0

static bool findEndpoints(int *outStartSample, int *outEndSample)
{
    if (DC_MODE)
    {
        *outStartSample = 0;
        *outEndSample = NUM_SAMPLES - 1;
        return true;
    }

    int startSample = 1;

    bool sign = adcData[0][VOLTAGE_CH] >= 0;

    //  Advance `startSample` to the first sample which differs in sign from the literal zeroth sample (this has to be a zero crossing)
    while (startSample < NUM_SAMPLES && ((adcData[startSample][VOLTAGE_CH] >= 0) == sign))
    {
        startSample++;
    }

    if (startSample == NUM_SAMPLES)
    {
        printf("sample overflow finding zero crossing\n");
        return false;
    }

    int halfPeriods = 0;
    int endSample = startSample;
    bool endSign = adcData[endSample][VOLTAGE_CH] >= 0;

    // Scan over all of the samples after `startSample` until the end
    for (int currentSample = startSample + 1; currentSample < NUM_SAMPLES; currentSample++)
    {
        bool currentSign = adcData[currentSample][VOLTAGE_CH] >= 0;

        // If the current sample now has a different sign to the last saved "end sample", updated
        // the saved "end sample" to this position (we have just found another zero crossing).
        if (currentSign != endSign)
        {
            endSample = currentSample;
            endSign = currentSign;
            halfPeriods++;
        }
    }

    printf("%d\n", halfPeriods);

    if (!halfPeriods)
    {
        printf("didn't find any half periods!?!\n");
        return false;
    }

    // Have we see roughly the expected number of half periods?
    // NOTE: 138 samples/halfperiod is a reasonable estimate for x16 oversampling, and
    // should be suitably multiplied/divided if the oversampling rate is changed.
#define EXPECTED_SAMPLES_PER_HALFPERIOD 136

    if (abs((halfPeriods * EXPECTED_SAMPLES_PER_HALFPERIOD) - (endSample - startSample)) > NUM_SAMPLES / 200)
    {
        printf("half periods and range disagree! halfPeriods=%d: %d vs %d - %d = %d\n", halfPeriods,
            halfPeriods * EXPECTED_SAMPLES_PER_HALFPERIOD,
            endSample, startSample, endSample - startSample);
        return false;
    }

    *outStartSample = startSample;
    *outEndSample = endSample;
    return true;
}

static void loop(spi_device_handle_t spi)
{
    // Throw away the old conversion result (if any)
    doRead(spi);
   
    for (int c = 0; c < NUM_SAMPLES; c++)
    {
        
        readAllChannels(spi, adcData[c]);
    }

   
    uint64_t start_time = esp_timer_get_time();
    int startSample, endSample;
    if (!findEndpoints(&startSample, &endSample)) {
        return;
    }

    uint64_t end_time = esp_timer_get_time();
    uint64_t duration_us = end_time - start_time;
    printf("Code section took %llu microseconds (%llu milliseconds)\n", duration_us, duration_us / 1000);

    printf("sample range: %d = %d - %d\n", endSample - startSample, startSample, endSample);

    for (int ch = 0; ch < 8; ch++)
    {
        calcRmsAndPower(ch, startSample, endSample);
    }

    printStored();
}
// #include <stdio.h>
// #include <inttypes.h>
// #include <math.h>
// #include "sdkconfig.h"
// #include "esp_system.h"
// #include "esp_timer.h"
// #include "freertos/FreeRTOS.h"
// #include "freertos/task.h"
// #include "driver/spi_master.h"
// #include "driver/gpio.h"
// #include "esp_wifi.h"
// #include "esp_event.h"  // Updated from esp_event_loop.h
// #include "esp_log.h"
// #include "mqtt_client.h"
// #include "esp_netif.h"  // Added for TCP/IP adapter replacement

// #define CONVST_PIN GPIO_NUM_4
// #define BUSY_PIN   GPIO_NUM_27
// #define CS_PIN     GPIO_NUM_15
// #define RESET_PIN  GPIO_NUM_25
// #define SCK_PIN    GPIO_NUM_5
// #define MISO_PIN   GPIO_NUM_21
// #define MOSI_PIN   GPIO_NUM_19

// #define NUM_SAMPLES 2000
// static const double LSB_10V = 20.0 / 262144.0;
// static const double V_FS_240Volt = LSB_10V * 509.9576;
// static const int32_t OFFSET[8] = {9,1,-2,6,-2,3,-6,-2};
// #define VOLTAGE_CH 0
// #define DC_MODE 0

// static uint8_t rawBytes[18];
// static int32_t adcData[NUM_SAMPLES][8];
// static double calcRms[8];
// static double calcPwr[8];

// // Hard-coded Wi-Fi credentials
// #define WIFI_SSID "PRINTER24"
// #define WIFI_PASS "herein3016830168."

// // Hard-coded MQTT
// #define MQTT_HOST "192.168.1.19"
// #define MQTT_PORT "8883"  // Changed to string
// #define MQTT_USER "power"
// #define MQTT_PASS "123456"
// #define MQTT_TOPIC "esp32/energymon"

// // Helper macro for string concatenation
// #define CONCAT_(x, y) x y
// #define CONCAT(x, y) CONCAT_(x, y)

// static void setup_pin_input(int pin)
// {
//     gpio_config_t io_conf = {
//         .pin_bit_mask = (1ULL << pin),
//         .mode = GPIO_MODE_INPUT,
//         .pull_up_en = GPIO_PULLUP_DISABLE,
//         .pull_down_en = GPIO_PULLDOWN_DISABLE,
//         .intr_type = GPIO_INTR_DISABLE
//     };
//     ESP_ERROR_CHECK(gpio_config(&io_conf));
// }

// static void setup_pin_output(int pin)
// {
//     gpio_config_t io_conf = {
//         .pin_bit_mask = (1ULL << pin),
//         .mode = GPIO_MODE_OUTPUT,
//         .pull_up_en = GPIO_PULLUP_DISABLE,
//         .pull_down_en = GPIO_PULLDOWN_DISABLE,
//         .intr_type = GPIO_INTR_DISABLE
//     };
//     ESP_ERROR_CHECK(gpio_config(&io_conf));
// }

// static void calcRmsAndPower(int ch, int startSample, int endSample)
// {
//     uint64_t sumRms = 0;
//     int64_t sumPwr = 0;
//     for (int i = startSample; i < endSample; i++) {
//         int32_t val = adcData[i][ch];
//         sumRms += val * val;
//         sumPwr += val * adcData[i][VOLTAGE_CH];
//     }
//     uint32_t numSamples = endSample - startSample;
//     calcRms[ch] = sqrt(((double)sumRms) / ((double)numSamples));
//     calcPwr[ch] = ((double)sumPwr) / ((double)numSamples);
// }

// static bool waitForBusy(int state, uint32_t timeoutMicros)
// {
//     int64_t then = esp_timer_get_time();
//     while (gpio_get_level(BUSY_PIN) != state) {
//         if (esp_timer_get_time() - then > timeoutMicros) {
//             return false;
//         }
//     }
//     return true;
// }

// static void doRead(spi_device_handle_t spi)
// {
//     if (!waitForBusy(0, 10000)) {
//         printf("low wait timeout\n");
//     }
//     gpio_set_level(CONVST_PIN, 0);
//     uint32_t then = esp_cpu_get_cycle_count();
//     while (esp_cpu_get_cycle_count() - then < 10);
//     gpio_set_level(CONVST_PIN, 1);
//     if (!waitForBusy(1, 10)) {
//         printf("high wait timeout\n");
//     }
//     gpio_set_level(CS_PIN, 0);
//     spi_transaction_t t = {
//         .length = 18*8,
//         .tx_buffer = NULL,
//         .rx_buffer = rawBytes,
//         .flags = 0
//     };
//     ESP_ERROR_CHECK(spi_device_polling_transmit(spi, &t));
//     gpio_set_level(CS_PIN, 1);
// }

// static void readAllChannels(spi_device_handle_t spi, int32_t *data)
// {
//     doRead(spi);
//     for (int ch = 0; ch < 8; ch++) {
//         int startBit = ch * 18;
//         int startByte = startBit / 8;
//         uint32_t buf = 0;
//         for (int i = 0; i < 3; i++) {
//             buf = (buf << 8) | rawBytes[startByte + i];
//         }
//         int shift = ((startByte + 3)*8) - (startBit+18);
//         uint32_t val = (buf >> shift) & 0x3FFFF;
//         if (val & 0x20000) val |= 0xFFFC0000;
//         data[ch] = val - OFFSET[ch];
//     }
// }

// static void printStored()
// {
//     printf("RMS0: %.6lf RMS Volts: %.6lf\n", calcRms[0]*LSB_10V, calcRms[0]*V_FS_240Volt);
//     for (int i = 1; i < 8; i++) {
//         printf("RMS%d: %.6lf\n", i, calcRms[i]*LSB_10V);
//     }
//     printf("PWR1: %.6lf\n", calcPwr[1]*V_FS_240Volt*LSB_10V);
//     printf("-----------------------------------------------------------------\n");
// }

// static bool findEndpoints(int *outStartSample, int *outEndSample)
// {
//     if (DC_MODE) {
//         *outStartSample = 0;
//         *outEndSample = NUM_SAMPLES-1;
//         return true;
//     }
//     int startSample = 1;
//     bool sign = adcData[0][VOLTAGE_CH] >= 0;
//     while (startSample < NUM_SAMPLES && ((adcData[startSample][VOLTAGE_CH] >= 0) == sign)) startSample++;
//     if (startSample == NUM_SAMPLES) return false;
//     int halfPeriods = 0;
//     int endSample = startSample;
//     bool endSign = adcData[endSample][VOLTAGE_CH] >= 0;
//     for (int currentSample = startSample+1; currentSample < NUM_SAMPLES; currentSample++) {
//         bool currentSign = adcData[currentSample][VOLTAGE_CH] >= 0;
//         if (currentSign != endSign) {
//             endSample = currentSample;
//             endSign = currentSign;
//             halfPeriods++;
//         }
//     }
//     if (!halfPeriods) return false;
//     *outStartSample = startSample;
//     *outEndSample = endSample;
//     return true;
// }

// static void loop_spi(spi_device_handle_t spi)
// {
//     doRead(spi);
//     for (int c = 0; c < NUM_SAMPLES; c++) readAllChannels(spi, adcData[c]);
//     int startSample, endSample;
//     if (!findEndpoints(&startSample, &endSample)) return;
//     for (int ch = 0; ch < 8; ch++) calcRmsAndPower(ch, startSample, endSample);
//     printStored();
// }

// // --- Wi-Fi connection ---
// static void wifi_event_handler(void* arg, esp_event_base_t event_base,
//                               int32_t event_id, void* event_data)
// {
//     if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START) {
//         esp_wifi_connect();
//     } else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED) {
//         esp_wifi_connect();
//     }
// }

// static void wifi_init(void)
// {
//     ESP_ERROR_CHECK(esp_netif_init());
//     ESP_ERROR_CHECK(esp_event_loop_create_default());
//     esp_netif_create_default_wifi_sta();

//     wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
//     ESP_ERROR_CHECK(esp_wifi_init(&cfg));

//     ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,
//                     ESP_EVENT_ANY_ID,
//                     &wifi_event_handler,
//                     NULL,
//                     NULL));

//     ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
//     wifi_config_t sta_config = {
//         .sta = {
//             .ssid = WIFI_SSID,
//             .password = WIFI_PASS
//         }
//     };
//     ESP_ERROR_CHECK(esp_wifi_set_config(ESP_IF_WIFI_STA, &sta_config));
//     ESP_ERROR_CHECK(esp_wifi_start());
// }

// // --- MQTT ---
// static esp_mqtt_client_handle_t mqtt_client = NULL;

// static void mqtt_start(void)
// {
//     char mqtt_uri[50];
//     snprintf(mqtt_uri, sizeof(mqtt_uri), "mqtts://%s:%s", MQTT_HOST, MQTT_PORT);
    
//     esp_mqtt_client_config_t mqtt_cfg = {
//         .broker.address.uri = mqtt_uri,
//         .credentials = {
//             .username = MQTT_USER,
//             .authentication.password = MQTT_PASS
//         }
//     };
    
//     mqtt_client = esp_mqtt_client_init(&mqtt_cfg);
//     esp_mqtt_client_start(mqtt_client);
// }

// // --- Main ---
// void app_main()
// {
//     printf("Starting ESP32 Energy Monitor\n");

//     setup_pin_output(CONVST_PIN);
//     setup_pin_input(BUSY_PIN);
//     setup_pin_output(CS_PIN);
//     setup_pin_output(RESET_PIN);

//     gpio_set_level(CONVST_PIN, 1);
//     gpio_set_level(CS_PIN, 1);
//     gpio_set_level(RESET_PIN, 0);

//     gpio_set_level(RESET_PIN, 1);
//     esp_rom_delay_us(1);
//     gpio_set_level(RESET_PIN, 0);
//     vTaskDelay(pdMS_TO_TICKS(1));

//     spi_bus_config_t buscfg = {
//         .mosi_io_num = MOSI_PIN,
//         .miso_io_num = MISO_PIN,
//         .sclk_io_num = SCK_PIN,
//         .quadwp_io_num = -1,
//         .quadhd_io_num = -1,
//         .max_transfer_sz = 0
//     };
//     ESP_ERROR_CHECK(spi_bus_initialize(HSPI_HOST, &buscfg, SPI_DMA_CH_AUTO));

//     spi_device_interface_config_t devcfg = {
//         .clock_speed_hz = 30*1000*1000,
//         .mode = 1,
//         .spics_io_num = -1,
//         .queue_size = 1
//     };
//     spi_device_handle_t spi;
//     ESP_ERROR_CHECK(spi_bus_add_device(HSPI_HOST, &devcfg, &spi));

//     wifi_init();
//     mqtt_start();

//     while (1) {
//         loop_spi(spi);
//         vTaskDelay(pdMS_TO_TICKS(1000));
//     }
// }